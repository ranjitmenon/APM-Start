{"ast":null,"code":"/**\n * @license Angular v17.3.8\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\n\n\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\n\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\n\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\n\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\n\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\n\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\n\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\n\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n\n  activeConsumer.consumerOnSignalRead(node); // This producer is the `idx`th dependency of `activeConsumer`.\n\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    // There's been a change in producers since the last execution of `activeConsumer`.\n    // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n    // replaced with `this`.\n    //\n    // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n    // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n    // to remove it from the stale producer's `liveConsumer`s.\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]); // At this point, the only record of `staleProducer` is the reference at\n      // `activeConsumer.producerNode[idx]` which will be overwritten below.\n    }\n  }\n\n  if (activeConsumer.producerNode[idx] !== node) {\n    // We're a new dependency of the consumer (at `idx`).\n    activeConsumer.producerNode[idx] = node; // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n    // placeholder value.\n\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\n\n\nfunction producerIncrementEpoch() {\n  epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\n\n\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n    return;\n  }\n\n  node.producerRecomputeValue(node); // After recomputing the value, we're no longer dirty.\n\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\n\n\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === undefined) {\n    return;\n  } // Prevent signal reads when we're updating the graph\n\n\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\n\n\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\n\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\n\n\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\n\n\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n\n  if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined || node.producerLastReadVersion === undefined) {\n    return;\n  }\n\n  if (consumerIsLive(node)) {\n    // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n    // which weren't dependencies after the recomputation.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  } // Truncate the producer tracking arrays.\n  // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n  // benchmarking has shown that individual pop operations are faster.\n\n\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\n\n\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node); // Poll producers for change.\n\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i]; // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n\n    if (seenVersion !== producer.version) {\n      return true;\n    } // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n\n\n    producerUpdateValueVersion(producer); // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\n\n\nfunction consumerDestroy(node) {\n  assertConsumerNode(node);\n\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  } // Truncate all the arrays to drop all connection from this node to the graph.\n\n\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;\n\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n  }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\n\n\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n\n  if (node.liveConsumerNode.length === 0) {\n    // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\n\n\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n  }\n\n  if (node.liveConsumerNode.length === 1) {\n    // When removing the last live consumer, we will no longer be live. We need to remove\n    // ourselves from our producers' tracking (which may cause consumer-producers to lose\n    // liveness as well).\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  } // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n  // live consumer, this is a no-op.\n\n\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx]; // Truncate the array.\n\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--; // If the index is still valid, then we need to fix the index pointer from the producer to this\n  // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\n\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\n\nfunction assertConsumerNode(node) {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\n\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\n\n\nfunction createComputed(computation) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node); // Record that someone looked at this signal.\n\n    producerAccessed(node);\n\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n\n    return node.value;\n  };\n\n  computed[SIGNAL] = node;\n  return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\n\n\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\n\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\n\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED'); // Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\n\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return { ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n\n      try {\n        newValue = node.computation();\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n\n      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n\n      node.value = newValue;\n      node.version++;\n    }\n\n  };\n})();\n\nfunction defaultThrowError() {\n  throw new Error();\n}\n\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\n\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\n\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\n\n\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\n\nfunction createSignal(initialValue) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n\n  const getter = () => {\n    producerAccessed(node);\n    return node.value;\n  };\n\n  getter[SIGNAL] = node;\n  return getter;\n}\n\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\nfunction signalGetFn() {\n  producerAccessed(this);\n  return this.value;\n}\n\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\n\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n\n  signalSetFn(node, updater(node.value));\n} // Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\n\n\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return { ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined\n  };\n})();\n\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.();\n}\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n  const node = Object.create(WATCH_NODE);\n\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n\n  node.fn = fn;\n  node.schedule = schedule;\n\n  const registerOnCleanup = cleanupFn => {\n    node.cleanupFn = cleanupFn;\n  };\n\n  function isWatchNodeDestroyed(node) {\n    return node.fn === null && node.schedule === null;\n  }\n\n  function destroyWatchNode(node) {\n    if (!isWatchNodeDestroyed(node)) {\n      consumerDestroy(node); // disconnect watcher from the reactive graph\n\n      node.cleanupFn(); // nullify references to the integration functions to mark node as destroyed\n\n      node.fn = null;\n      node.schedule = null;\n      node.cleanupFn = NOOP_CLEANUP_FN;\n    }\n  }\n\n  const run = () => {\n    if (node.fn === null) {\n      // trying to run a destroyed watch is noop\n      return;\n    }\n\n    if (isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n\n    node.dirty = false;\n\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n\n    node.hasRun = true;\n    const prevConsumer = consumerBeforeComputation(node);\n\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn(),\n    destroy: () => destroyWatchNode(node),\n    [SIGNAL]: node\n  };\n  return node.ref;\n}\n\nconst NOOP_CLEANUP_FN = () => {}; // Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\n\n\nconst WATCH_NODE = /* @__PURE__ */(() => {\n  return { ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: node => {\n      if (node.schedule !== null) {\n        node.schedule(node.ref);\n      }\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN\n  };\n})();\n\nfunction setAlternateWeakRefImpl(impl) {// TODO: remove this function\n}\n\nexport { REACTIVE_NODE, SIGNAL, SIGNAL_NODE, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, createWatch, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, setActiveConsumer, setAlternateWeakRefImpl, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalSetFn, signalUpdateFn };","map":{"version":3,"names":["defaultEquals","a","b","Object","is","activeConsumer","inNotificationPhase","epoch","SIGNAL","Symbol","setActiveConsumer","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","version","lastCleanEpoch","dirty","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","Error","ngDevMode","idx","assertConsumerNode","length","consumerIsLive","staleProducer","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","producerIncrementEpoch","producerUpdateValueVersion","consumerPollProducersForChange","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","prevConsumer","i","pop","producer","seenVersion","consumerDestroy","indexOfThis","assertProducerNode","push","lastIdx","idxProducer","createComputed","computation","create","COMPUTED_NODE","computed","ERRORED","error","UNSET","COMPUTING","equal","oldValue","newValue","err","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","fn","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","getter","setPostSignalSetFn","signalGetFn","signalSetFn","signalValueChanged","signalUpdateFn","updater","createWatch","schedule","allowSignalWrites","WATCH_NODE","registerOnCleanup","cleanupFn","isWatchNodeDestroyed","destroyWatchNode","NOOP_CLEANUP_FN","run","hasRun","ref","notify","cleanup","destroy","setAlternateWeakRefImpl","impl"],"sources":["/home/ranjitmenon/APM-Start/APM-Start/node_modules/@angular/core/fesm2022/primitives/signals.mjs"],"sourcesContent":["/**\n * @license Angular v17.3.8\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ?\n            `Assertion error: signal read during notification phase` :\n            '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] =\n            consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        node.dirty = false;\n        node.lastCleanEpoch = epoch;\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n    // benchmarking has shown that individual pop operations are faster.\n    while (node.producerNode.length > node.nextProducerIndex) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length =\n        0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    assertConsumerNode(node);\n    if (node.liveConsumerNode.length === 0) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    assertConsumerNode(node);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n    }\n    if (node.liveConsumerNode.length === 1) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error('Detected cycle in computations.');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                newValue = node.computation();\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n                node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction createSignal(initialValue) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    const getter = (() => {\n        producerAccessed(node);\n        return node.value;\n    });\n    getter[SIGNAL] = node;\n    return getter;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn() {\n    producerAccessed(this);\n    return this.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    signalSetFn(node, updater(node.value));\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.();\n}\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\nexport { REACTIVE_NODE, SIGNAL, SIGNAL_NODE, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, createWatch, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, setActiveConsumer, setAlternateWeakRefImpl, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalSetFn, signalUpdateFn };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}